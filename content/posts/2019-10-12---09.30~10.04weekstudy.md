---
title: 09.30~10.04 한 주 정리 part.6
date: "2019-10-14T23:55:03.284Z"
template: "post"
draft: false
slug: "/posts/javascript-part6/"
category: "JavaScript"
tags:
  - "JavaScript"

description: "HTML에서의 JS / DOM / 이벤트"
socialImage: "/media/gutenberg.jpg"
---

# HTML에서의 JS 로드하기

- inline 방식 – html 태그에 직접 javascript를 기술하는 방식이다. 장점은 태그에 관련된 스크립트가 분명하게 드러난다. 하지만 정보와 제어가 섞여 있기 때문에 정보로서의 가치가 떨어짐.
- Script 방식 - script 태그를 만들어서 여기에 자바스크립트 코드를 삽입하는 방식. 장점은 html태그와 js 코드를 분리할 수 있다.
- 외부 파일로 분리
  js를 별도의 파일로 분리할 수도 있다. 장점은 보다 엄격하게 정보와 제어를 분리할 수 있다. 하나의 js 파일을 여러 웹페이지에서 로드함으로서 js의 재활용성을 높일 수 있다. 캐쉬를 통해서 속도의 향상, 전송량의 경량화를 도모할 수 있다. 유지보수의 편의성(중복 제거)

※ Scripts 파일은 태그보다 페이지 하단(body tag 안에서 맨뒤)에 위치시키는 것이 더 좋음

# DOM (Document Object Model)

- DOM(돔)이란 웹페이지의 HTML을 계층화시켜 트리구조로 만든 객체(Object) 모델입니다.
- JavaScript는 이 model로 웹 페이지에 접근하고, 페이지를 수정할 수 있습니다.
- DOM은 HTML인 웹페이지와 스크립팅언어(JavaScript)를 서로 잇는 역할입니다.

JS로 html문서를 제어하려면 젤 처음에 해야 하는 일이 제어의 대상에 해당되는 객체를 찾는 것이다.

> 객체 찾는 방법은 document 객체의 조회 관련 메소드 이용

- document.getElementsByTagName – HTML tag 이름 ul/ li/ p/ div 으로 찾아냄 보통 tag가 중복되서 많이 쓰이므로 찾으려는 태그명에 대해 배열값으로 리턴한다.
- document.getElementsById – ID명으로 찾음 – ID는 유일한 값이므로 유일한 객체만 검색됨
- document.getElementsByClassName - class명으로 찾아냄 – 클래스도 같은 이름으로 여러 개가 쓰일 수 있으므로 tagName과 같게 배열값으로 리턴한다.
- document.querySelector – css의 선택자의 문법을 이용한 객체 조회 – 위의 3개를 다 쓸 수 있는 듯 but 1개만 검색됨
- document.querySelectorall – css 선택자 모든 객체 조회 – 맨 위의 3개를 다 쓸 수 있는 강력한 도구
  > 속성 - 엘리먼트의 속성을 알아내고 변경하는 API – MTV 모델에서 많이 쓰임
- Element.getAttribute(name) – 속성을 가져오는 것
- Element.setAttribute(name, value) – 속성을 변경, 추가 하는 것
- Element.hasAttribute(name); - 속성의 존재여부를 boolean값으로 확인
- Element.removeAttribute(name) ; - 속성을 제거하는 것

### Node 객체

> 관계 - 엘리먼트는 서로 부모, 자식, 혹은 형제자매 관계로 연결되어 있다.
>
> > 각각의 Node가 다른 Node와 연결된 정보를 보여주는 API를 통해서 문서를 프로그래밍적으로 탐색할 수 있다.

- Node.childNodes – 자식노드들을 유사배열에 담아서 리턴
- Node.firstChild – 첫번째 자식 노드
- Node.lastChild – 마지막 자식 노드
- Node.nextSibling – 다음 형제 노드
- Node.previousSibling – 이전형제 노드
- Node.contains() – 가지고 있는 자식 노드
- Node.hasChildNodes() – 특정 자식 노드를 가지고 있느냐 없느냐

### 노드의 종류

> Node 객체는 모든 구성요소를 대표하는 객체이기 때문에 각각의 구성요소가 어떤 카테고리에 속하는 것인지를 알려주는 식별자를 제공한다.

- Node.nodeType - 노드의 종류에 따라서 정해진 상수가 존재한다.

- Node.nodeName – name은 태그명을 의미한다.
  > 값 - Node 객체의 값을 제공하는 API
- Node.nodeValue
- Node.textContent
  > 자식관리 - Node 객체의 자식을 추가하는 방법에 대한 API
- ★ Node.appendChild()
- Node.removeChild()

### 노드 추가

- appendChild(child)- 노드의 마지막 자식으로 주어진 엘리먼트 추가
- insertBefore(newElement, referenceElement) - appendChild와 동작방법은 같으나 두번째 인자로 엘리먼트를 전달 했을 때 이것 앞에 엘리먼트가 추가된다.
  > 위치 지정해서 엘리먼트를 추가하는 방법
      노드를 추가하기 위해서는 추가할 엘리먼트를 생성해야 하는데 이것은 document 객체의 기능이다. 아래 API는 노드를 생성하는 API이다.
- document.createElement(tagName) -엘리먼트 노드를 추가한다.
- document.createTextNode(data) - 텍스트 노드를 추가한다.

### 노드 제거

메소드는 삭제 대상의 부모 노드 객체의 것을 실행해야 한다는 점에 유의하자.

- removeChild(child)

### 노드 교체

- replaceChild(newchild, oldchild)

### 문자열로 노드 제어 (위의 방법보다 훨씬 쉬움)

- innerHTML - 문자열로 자식 노드를 만들 수 있는 기능을 제공한다. 또한 자식 노드의 값을 읽어올 수도 있다. 선택한 엘리먼트는 검색되지 않는다 (부모노드는 검색 범위에서 제외)

- outerHTML - outerHTML은 선택한 엘리먼트를 포함해서 처리된다.

# 이벤트

★ addEventListener() 메서드 ★

<code>target.addEventListener(type, listener[, options]);</code>

<code>target:이벤트 발생시킬 타겟(이게 젤중요함 어디에 적용되느냐!!) (type:이벤트 종류, listener: 이벤트 작동할 로직 or 로직 있는함수
[,이벤트 특성])</code>

- EventTarget의 addEventListener() 메서드는 지정한 이벤트가 대상에 전달될 때마다 호출할 함수를 설정합니다. 일반적인 대상은 Element, Document, Window지만, XMLHttpRequest와 같이 이벤트를 지원하는 모든 객체를 대상으로 지정할 수 있습니다.
- addEventListener()는 EventTarget의 주어진 이벤트 유형에, EventListener를 구현한 함수 또는 객체를 이벤트 처리기 목록에 추가해 작동합니다.

> 키이벤트

사람이 키보드를 누르면 발생하는 이벤트 입니다.

- 키보드를 눌렀을 때 발생하는 keydown
- 키보드를 누르고 떼는 순간 발생하는 keyup
- 키보드를 눌러 어떤 텍스트가 작성되는 순간 발생하는 keypress

등등 더 많은 이벤트가 존재한다 다른 이벤트를 보려면 밑의 링크를 클릭하시면 됩니다.

[[이벤트 종류 더 보기](https://developer.mozilla.org/ko/docs/Web/Events)]
