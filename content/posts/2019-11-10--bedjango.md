---
title: Django Apprenticeship Study Part.3
date: "2019-11-10T21:30:03.284Z"
template: "post"
draft: false
slug: "/posts/django-part3/"
category: "Python/Django/Database"
tags:
  - "Python/Django/Database"

description: "Database & django orm basic concept"
socialImage: "/media/gutenberg.jpg"
---

## previously

- django project create and foundation settings

# 커스텀 앱 디텍토리 생성

☞ python manage.py startapp books ☜ 치면 앱 만들 수 있음

- 단, 해당 프로젝트 디렉토리 안에서 명령어를 쳐야 정상적으로 만들어 진다

기본적인 백엔드 기능을 구현하는 곳으로서 전체적인 아키텍쳐에 따라 달라지지만 기본적으로 구현하고자 하는 기능별/Database table별로 구분하여 앱 디렉토리를 만들어서 구별하는 협업 개발을 할 때 좋다

# 앱 디텍토리 process

1. models.py에서 db모델링 및 설계
2. views.py에서 엔드 포인트 로직 설계
3. urls.py에서 엔드 포인트 마지막 주소 설계해서 웹과 연결
4. views.py에서 필요한 데코레이터나 클래스 혹은 함수를 지정하는 별도의 파일 생성

# 1. Models.py 설계

클래스를 생성하여 DB 테이블 객체를 구성을 정의하는 곳
장고는 many-to-one, many-to-many, and one-to-one과 같은 모든 일반 데이터베이스 관계를 지원합니다.

## 모델의 정의(make model)

장고 안의 모델은 객체의 특별한 종류입니다. 이 모델을 저장하면 그 내용이 데이터베이스에 저장되는 것이 특징이다.

- 데이터베이스(DATABASE)

데이터의 집합입니다. 데이터들이 모여 있는 저장 공간이다. 이곳에 웹에서 작성한 사용자에 대한 정보나 상품 정보 등의 정보가 저장되어 있습니다. 데이터베이스는 여러 종류가 있습니다. mysql, mariaDB, oracle, postgreSQL,sqlite등이 있습니다. 장고는 이 모든 DB를 지원합니다. ORM이라는 개념으로 DB에 종속적이지 않게 지원을 해줍니다.

- 객체(object)

객체란 속성과 행동을 모아놓은 것이라 할 수 있다. 객체가 중요한 이유는 객체 지향 프로그래밍 개발 방법 때문이다.

- 객체 지향 프로그래밍(object oriented programming)

이 개발 방법은 프로그램이 어떻게 작동해야 하는지 모든 것을 하나하나 지시하는 것 대신, 모델을 만들어 그 모델이 어떤 역할을 가지고 어떻게 행동해야 하는지 정의하여 서로 알아서 상호작용할 수 있도록 만드는 것을 말한다.
기본적으로 객체지향설계 개념은 현실에 존재하는 것을 속성과 행위로 나타내는 것입니다. 여기서 속성은 객체 속성(properties), 행위는 메서드(methods)로 구현됩니다.

- ORM(object relational mapping)

  - 객체(Object)와 관계형 데이터베이스(Relational Database)의 데이터를 매핑(Mapping)해주는 것을 의미한다.

  - 객체 간의 관계를 바탕으로 SQL을 자동을 생성해서 sql 쿼리문 없이도 데이터베이스의 데이터들을 다룰 수 있다

  ### 1. 장점

  - 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다.
    - 선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 줄어든다.
    - 각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다.
    - SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.
  - 재사용 및 유지보수의 편리성이 증가한다.
    - ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용 할 수 있다. 때문에 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다.
    - 매핑정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다.
  - DBMS에 대한 종속성이 줄어든다.
    - 대부분 ORM 솔루션은 DB에 종속적이지 않다.
    - 종속적이지 않다는것은 구현 방법 뿐만아니라 많은 솔루션에서 자료형 타입까지 유효하다.
    - 프로그래머는 Object에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.

  ### 2.단점

  - 완벽한 ORM 으로만 서비스를 구현하기가 어렵다.
    - 사용하기는 편하지만 설계는 매우 신중하게 해야한다.
    - 프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 수 있다.
    - 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다.
    - 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는등 별도의 튜닝이 필요한 경우가 있다.
    - DBMS의 고유 기능을 이용하기 어렵다. (하지만 이건 단점으로만 볼 수 없다 : 특정 DBMS의 고유기능을 이용하면 이식성이 저하된다.)
  - 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.
    - 이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다.

# 모델링이란?

1. 정의
   사람이 살아가면서 나타날 수 있는 다양한 현상은 사람, 사물, 개념 등에 의해 발생된다고 할 수 있으며 모델링은 이것을 표기법에 의해 규칙을 가지고 표기하는 것 자체를 의미한다.

- 업무에서 필요로 하는 데이터를 시스템 구축 방법론에 의해 분석하고 설계하여 정보시스템을 구축하는 과정으로 정의할 수 있다

2. 특징

   1. 추상화(모형화, 가설적)는 현실세계를 일정한 형식에 맞추어 표현을 한다는 의미로 정리할 수 있다. 즉, 다양한 현상을 일정한 양식인 표기법에 의해 표현한다는 것이다.
   2. 단순화는 복잡한 현실세계를 약속된 규약에 의해 제한된 표기법이나 언어로 표현하여 쉽게 이해할 수 있도록 하는 개념을 의미한다.
   3. 명확화는 누구나 이해하기 쉽게 하기 위해 대상에 대한 애매모호함을 제거하고 정확(正確)하게 현상을 기술하는 것을 의미한다.

3. 관점

   1. 데이터관점 : 업무가 어떤 데이터와 관련이 있는지 또는 데이터간의 관계는 무엇인지에 대해서 모델링하는 방법(What, Data)
   2. 프로세스관점 : 업무가 실제하고 있는 일은 무엇인지 또는 무엇을 해야 하는지를 모델링하는 방법(How, Process)
   3. 데이터와 프로세스의 상관관점 : 업무가 처리하는 일의 방법에 따라 데이터는 어떻게 영향을 받고 있는지 모델링하는 방법(Interaction)으로 설명될 수 있다.

4. 데이터 모델링의 3단계

   그 중에서 장고 모델링과 연관이 되어 있는 **논리적 데이터 모델링**만을 얘기해본다.

   논리 데이터 모델링은 데이터베이스 설계 프로세스의 Input으로써 비즈니스 정보의 논리적인 구조와 규칙을 명확하게 표현하는 기법 또는 과정이라 할 수 있다.

   논리 데이터 모델링의 결과로 얻어지는 논리 데이터 모델은 데이터 모델링이 최적화된 스키마 설계를 하기 전에 액세스하고, 누가 데이터에 액세스하며, 그러한 액세스의 전산화와는 독립적으로 다시 말해서 누가(Who), 어떻게(How: Process) 그리고 전산화와는 별개로 비즈니스 데이터에 존재하는 사실들을 인식하여 **기록**하는 것이다.

   데이터 모델링 과정에서 가장 핵심이 되는 부분이 논리 데이터 모델링이라고 할 수 있다. 데이터 모델링이란 모델링 과정이 아닌 별도의 과정을 통해서 조사하고 결정한 사실을 단지 ERD라는 그림으로 그려내는 과정을 말하는 것이 아니다. 시스템 구축을 위해서 가장 먼저 시작할 **기초적인 업무조사**를 하는 초기단계에서부터 인간이 결정해야 할 대부분의 사항을 모두 정의하는 시스템 설계의 전 과정을 지원하는 **과정의 도구**라고 해야 할 것이다.

   이 단계에서 수행하는 또 한가지 중요한 활동은 **정규화**이다.  
   정규화는 논리 데이터 모델 상세화 과정의 대표적인 활동으로, 논리 데이터 모델의 일관성을 확보하고 중복을 제거하여 속성들이 가장 적절한 엔터티에 배치되도록 함으로써 보다 신뢰성있는 데이터구조를 얻는데 목적이 있다.

   논리 데이터 모델의 **상세화**는 \__식별자 확정, 정규화, M:M 관계 해소, 참조 무결성 규칙 정의_ 등을 들 수 있으며, 추가적으로 이력 관리에 대한 전략을 정의하여 이를 논리 데이터 모델에 반영함으로써 데이터 모델링을 완료하게 된다.

5. 좋은 데이터 모델링이란?
   - 완전성(Completeness)
   - 중복배제(Non-Redundancy)
   - 업무규칙(Business Rules)
   - 데이터 재사용(Data Reusability)
   - 의사소통(Communication)
   - 통합성(Integration)

# Database Table Relationship

- 일대일 ( 1:1 )
- 일대다 ( 1:N )
- 다대다 ( N:M )

## 1. One To One (1:1)

어느 엔티티 쪽에서 상대 엔티티를 보더라도 반드시 단 하나씩 관계를 가지는 것을 말합니다.

예를 들면, 학번과 학생간의 관계를 들 수 있습니다. 학생은 한 개의 학번만을 가질 수 있고 학번 또한 하나의 학생만을 가질 수 있는 관계라고 할 수 있습니다.

이러한 관계를 1:1 관계라고 합니다.

![1:1](https://fmhelp.filemaker.com/help/18/fmp/en/FMP_Help/images/one-to-one.png)

## 2. One To Many (1:N)

한 쪽 엔티티가 관계를 맺은 엔티티 쪽의 여러 객체를 가질 수 있는 것을 의미합니다.

이 관계는 매우 흔한 방식이며, 실제 DB를 설계할 때 자주 쓰이는 방식입니다.

예를 들면, 부모와 자식 관계라고 생각하시면 됩니다.  
계층적인 구조로 이해할 수도 있습니다.

![1:N](https://fmhelp.filemaker.com/help/18/fmp/en/FMP_Help/images/one-to-many.png)

## 3. Many To Many (N:N)

양쪽 엔티티 모두에서 1 : M 관계가 존재할 때 나타나는 모습입니다.
즉, 서로가 서로를 1:N 관계로 보고 있는 것입니다.

예를 들면, 쇼핑몰에서 회원과 상품이 관계를 맺을 수 있습니다.
한 회원은 쇼핑몰의 여러 상품들을 가질 수 있습니다.
청바지, 모자, 티셔츠, 남방 등... 다 제가 가질 수 있죠.
반대로 한 티셔츠도 여러 회원들을 가질 수 있습니다.
하나의 티셔츠를 나도 친구도 부모님도 가질 수 있습니다.

관계형 데이터베이스 시스템에서는 일반적으로 두 테이블간에 직접적인 다 대다 관계를 구현할 수 없습니다.
N:N 관계를 깰 수 1:N 관계 A는 전화, 세 번째 테이블을 사용하여 테이블을 만들어야 한다 그 것을**조인**테이블이라고 한다. 결합 테이블의 각 레코드는 결합 하는 두 테이블 의 기본 키 값을 포함하는 일치 필드를 포함 합니다. 조인 테이블에서 이러한 일치 필드는 외래 키 입니다. 이러한 외래 키 필드는 조인 테이블의 레코드가 조인하는 테이블에서 생성 될 때 데이터로 채워집니다.

N : N 관계의 전형적인 예는 학생과 수업 사이의 관계입니다. 학생은 많은 수업에 등록 할 수 있으며 수업에는 많은 학생이 포함될 수 있습니다.

다음 예제에는 각 학생의 레코드가 포함 된 Students 테이블과 각 클래스의 레코드가 포함 된 Classes 테이블이 포함됩니다. 조인 테이블 인 Enrollments는 두 테이블 사이에 하나씩 일대 다 관계를 만듭니다.

![N:N](https://fmhelp.filemaker.com/help/18/fmp/en/FMP_Help/images/relational.07.06.1.png)

### N:N 관계에 대한 결합 테이블을 설정하려면 다음을 수행해야 한다

    1. 위 예를 사용하여 Enrollments라는 테이블을 만듭니다.
    조인테이블이됩니다.

    2. 등록 테이블에서 학생 ID 필드와 클래스 ID 필드를 만듭니다.

    결합 테이블은 일반적으로 다른 테이블에 포함되지 않는 필드를 보유합니다. 수업을 시작한 날짜를 추적하는 날짜 필드와 수업을 수강하기 위해 학생이 지불 한 비용을 추적하는 비용 필드와 같은 필드를 등록 테이블에 추가 할 수 있습니다.

    3. 테이블에서 두 학생 ID 필드 사이의 관계를 만듭니다. 그런 다음 테이블에서 두 클래스 ID 필드 사이의 관계를 작성하십시오.

    이 디자인을 사용하여 학생이 3 개의 수업에 등록하는 경우 해당 학생은 학생 테이블에 1 개의 레코드와 등록 테이블에 3 개의 레코드 (학생이 등록한 각 클래스에 대해 하나씩)를 갖게됩니다.

## 기본 키(Primary Key)

설계자가 여러 후보키 중 하나를 선택하여 정의한 식별자 (유일성, 최소성)

기본키의 모든 필드의 값은 null 이 없다.

## 외래 키(ForeignKey)

어떤 릴레이션에 소속된 속성 또는 속성 집합이 다른 릴레이션의 기본키가 되는 키다.  
다시 말해 다른 릴레이션의 기본키를 그대로 참조하는 속성의 집합이 외래키다. 외래키는 릴레이션들 사이의 관계를 올바르게 표현하기 위해 필요하다.  
외래키는 반드시 다른 릴레이션의 기본키를 참조해야 하며 외래키의 도메인은 참조되는 기본키와 같게 정의되어야 한다.
