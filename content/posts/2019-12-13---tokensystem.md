---
title: Token System
date: "2019-12-13T23:30:03.284Z"
template: "post"
draft: false
slug: "/posts/django/userauthmethod/token"
category: "Python/Django/Token/JWT"
tags:
  - "Python/UserAuthMethod/Token/JWT"

description: "Token system & user auth management at webpage in django"
socialImage: "/media/gutenberg.jpg"
---

# 사용자 인증 정보 관리

token system을 이해하기 위해서는 선행되어서 이해해야 할 중요한 것이 바로 사용자 인증 정보 관리이다.
token system이라는 것은 사용자 인증 정보 관리를 한 방편이기 때문이다.

사용자 인증정보 관리라는 것은 서비스 페이지를 이용한 유저가 DB에 저장되어 있는 회원 유저이고 로그인한 상태인지를 계속 인지하고 관리하는 것을 말한다.

## 사용자의 인증정보를 관리하는 방식

1.  세션 기반 인증입니다. 이는 서버 기반 인증이라고 불리기도 합니다.

    이 인증 시스템은 이전부터 수 많은 웹서비스로서부터 사용이 되고 있는데요, 이름이 그렇듯, 만약에 유저가 로그인을 하게 되면, 서버측에서 유저가 현재 로그인 중이라는 인증정보를 기억하고 있어야 합니다. 그리고 이 정보를 세션 이라고 부릅니다.

    세션을 유지하기 위해서는 여러가지 방법이 사용되는데, 메모리, 디스크, 데이터베이스 시스템에 이를 저장합니다. 하지만 이 시스템엔 몇가지 문제점이 있는데, 이 문제점들은 큰 규모의 어플리케이션을 개발하는 것에 있어서 걸림돌이 되곤 했습니다.
    문제점은 로그인 유저수가 많아지면 성능에 과부하가 쉽게 온다는 점과 서버확장이 여의치 않다는 것입니다.

# 2. Token System

사용자의 인증을 하는 방식을 토큰을 통해서 관리하는 방식으로 최근 몇 년동안 대세로 자리 잡았습니다. 그러면 왜 대세가 되었는가?

## 1. Stateless 서버 & 높은 확장성

Stateless 서버를 이해하려면 먼저 Stateful 서버가 무엇인지 알아야합니다. Stateful 서버는 클라이언트에게서 요청을 받을 때 마다, 클라이언트의 상태를 계속해서 유지하고, 이 정보를 서비스 제공에 이용합니다.

stateful 서버의 예제로는 세션을 유지하는 웹서버가 있습니다. 예를들어 유저가 로그인을 하면, 세션에 로그인이 되었다고 저장을 해 두고, 서비스를 제공 할 때에 그 데이터를 사용합니다. 여기서 이 세션은, 서버컴퓨터의 메모리에 담을 때도 있고, 데이터베이스 시스템에 담을 때도 있습니다.

Stateless 서버는 반대로, 상태를 유지 하지 않습니다. 상태정보를 저장하지 않으면, 서버는 클라이언트측에서 들어오는 요청만으로만 작업을 처리합니다. 이렇게 상태가 없는 경우 클라이언트와 서버의 연결고리가 없기 때문에 서버의 확장성 (Scalability) 이 높아집니다.

서버 시스템이 분산이 되어있어도, 유저는 같은 토큰으로 서버에 요청을 하면 되고, 서버는 그저 그 토큰이 위조되지 않았는지만 검증을 하고 데이터베이스 조회도 할 필요 없이 바로 유저임을 신뢰하고 처리를 하면 되기 때문입니다.

## 2. 모바일 어플리케이션에 적합하다

만약에 Android / iOS 모바일 어플리케이션을 개발 한다면, 안전한 API 를 만들기 위해선 쿠키같은 인증시스템은 이상적이지 않습니다. (쿠키 컨테이너를 사용해야하죠). 토큰 기반 인증을 도입한다면, 더욱 간단하게 이 번거로움을 해결 할 수 있습니다.

## 3. 확장성(Extensibility)이 좋다(소셜로그인 기능 구현)

여기서의 확장성은, Scalability 와는 또 다른 개념입니다. Scalability 는 서버를 확장하는걸 의미하는 반면, Extensibility 는 로그인 정보가 사용되는 분야를 확장하는것을 의미합니다.

토큰을 사용하여 다른 서비스에서도 권한을 공유 할 수 있습니다
  
대표적인 예제로는, OAuth 가 있습니다. 페이스북/구글/카카오/네이버 같은 소셜 계정들을 이용하여 다른 웹서비스에서도 로그인 할 수 있게 할 수 있습니다.

## 4. 여러 플랫폼 및 도메인

어플리케이션과 서비스의 규모가 커지면, 우리는 여러 디바이스를 호환 시키고, 더 많은 종류의 서비스를 제공하게 됩니다. 토큰을 사용한다면, 그 어떤 디바이스에서도, 그 어떤 도메인에서도, 토큰만 유효하다면 요청이 정상적으로 처리 됩니다. 서버측에서 어플리케이션의 응답부분에 다음 헤더만 포함시켜주면 되지요.

## Token system 작동 원리

토큰 기반 시스템은 stateless 합니다. 무상태. 즉 상태유지를 하지 않는다는 것이죠. 이 시스템에서는 더 이상 유저의 인증 정보를 서버나 세션에 담아두지 않습니다. 이게 가장 핵심적인 개념이다.

### 구현방식 순서

1. 유저가 아이디와 비밀번호로 로그인을 합니다
2. 서버측에서 해당 계정정보를 검증합니다.
3. 계정정보가 정확하다면, 서버측에서 유저에게 signed 토큰을 발급해줍니다.
4. 여기서 signed 의 의미는 해당 토큰이 서버에서 정상적으로 발급된 토큰임을 증명하는 signature 를 지니고 있다는 것입니다
5. 클라이언트 측에서 전달받은 토큰을 저장해두고, 서버에 요청을 할 때 마다, 해당 토큰을 함께 서버에 전달합니다.
   이 때 웹서버에서 토큰을 서버에 전달 할 때에는, **HTTP 요청의 헤더**에 토큰값을 포함시켜서 전달합니다.
6. 서버는 토큰을 검증하고, 요청에 응답합니다.

![서버와 클라이언트간의 토큰 교환방식](https://velopert.com/wp-content/uploads/2016/12/token-diagram.png)

# 웹 표준 기반의 Token JWT

토큰 기반 인증 시스템의 구현체인 JWT는 웹 표준 RFC 7519 에 등록이 되어있습니다. 따라서 여러 환경에서 지원이 되며 (.NET, Ruby, Java, Node.js, Python, PHP …) 수많은 회사의 인프라스트럭쳐에서 사용 되고 있습니다 (구글, 마이크로소프트 …)

# JWT(JSON Web Token)

1. 수많은 프로그래밍 언어에서 지원됩니다  
   JWT 는 C, Java, Python, C++, R, C#, PHP, JavaScript, Ruby, Go, Swift 등 대부분의 주류 프로그래밍 언어에서 지원됩니다.

2. 자가 수용적 (self-contained) 입니다  
   JWT 는 필요한 모든 정보를 자체적으로 지니고 있습니다. JWT 시스템에서 발급된 토큰은, 토큰에 대한 기본정보, 전달 할 정보 (로그인시스템에서는 유저 정보를 나타내겠죠?) 그리고 토큰이 검증됐다는것을 증명해주는 signature 를 포함하고있습니다.

3. 쉽게 전달 될 수 있습니다  
   JWT 는 자가수용적이므로, 두 개체 사이에서 손쉽게 전달 될 수 있습니다. 웹서버의 경우 HTTP의 헤더에 넣어서 전달 할 수도 있고, URL 의 파라미터로 전달 할 수도 있습니다.

# JWT 구조

JWT 는 . 을 구분자로 3가지의 문자열로 되어있습니다. 구조는 다음과 같이 이루어져있습니다:
![JWT구조](https://velopert.com/wp-content/uploads/2016/12/jwt.png)

## 1. Header

Header 는 두가지의 정보를 지니고 있습니다.

- typ: 토큰의 타입을 지정합니다. 바로 JWT 이죠.
- alg: 해싱 알고리즘을 지정합니다. 해싱 알고리즘으로는 보통 HMAC SHA256 혹은 RSA 가 사용되며, 이 알고리즘은, 토큰을 검증 할 때 사용되는 signature 부분에서 사용됩니다.

![header](https://blog.martinwork.co.kr/images/jwt/jwt03.png)

## 2. Payload(정보)

Payload 부분에는 토큰에 담을 정보가 들어있습니다. 여기에 담는 정보의 한 ‘조각’ 을 클레임(claim) 이라고 부르고, 이는 name / value 의 한 쌍으로 이뤄져있습니다. 토큰에는 여러개의 클레임 들을 넣을 수 있습니다.

클레임 의 종류는 다음과 같이 크게 세 분류로 나뉘어져있습니다

- 등록된 (registered) 클레임,
- 공개 (public) 클레임,
- 비공개 (private) 클레임

### 1) 등록된 클레임

등록된 클레임들은 서비스에서 필요한 정보들이 아닌, 토큰에 대한 정보들을 담기위하여 이름이 이미 정해진 클레임들입니다. 등록된 클레임의 사용은 모두 선택적 (optional)이며, 이에 포함된 클레임 이름들은 다음과 같습니다:

- iss: 토큰 발급자 (issuer)
- sub: 토큰 제목 (subject)
- aud: 토큰 대상자 (audience)
- exp: 토큰의 만료시간 (expiraton), 시간은 NumericDate 형식으로 되어있어야 하며 (예: 1480849147370) 언제나 현재 시간보다 이후로 설정되어있어야합니다.
  nbf: Not Before 를 의미하며, 토큰의 활성 날짜와 비슷한 개념입니다. 여기에도 NumericDate 형식으로 날짜를 지정하며, 이 날짜가 지나기 전까지는 토큰이 처리되지 않습니다.
- iat: 토큰이 발급된 시간 (issued at), 이 값을 사용하여 토큰의 age 가 얼마나 되었는지 판단 할 수 있습니다.
- jti: JWT의 고유 식별자로서, 주로 중복적인 처리를 방지하기 위하여 사용됩니다. 일회용 토큰에 사용하면 유용합니다.

### 2) 공개 클레임

공개 클레임들은 충돌이 방지된 (collision-resistant) 이름을 가지고 있어야 합니다. 충돌을 방지하기 위해서는, 클레임 이름을 URI 형식으로 짓습니다.

```
    {"https://localhost:8000/user/is_admin": True}
```

### 3) 비공개 (private) 클레임

등록된 클레임도아니고, 공개된 클레임들도 아닙니다. 양 측간에 (보통 클라이언트 <->서버) 협의하에 사용되는 클레임 이름들입니다. 프론트와 백엔드 사이에 제공되어야할 정보값을 정한다고 보면 됩니다. 공개 클레임과는 달리 이름이 중복되어 충돌이 될 수 있으니 사용할때에 유의해야합니다.

```
{
    "username": "ctsiam"
}
```

### 4) 예제 payload

```
{
    "iss": "ctsict.com",
    "exp": SETTINGS['secret'], # exp 정보가 있는 모듈 임포트해서 썼다.
    "https://localhost:8000/user/is_admin": True,
    "userId": "1112532453452",
    "username": "kimalo"
}
```

![payload 영역](https://blog.martinwork.co.kr/images/jwt/jwt04.png)

## 3. Signature(서명)

JSON Web Token 의 마지막 부분은 바로 서명(signature) 입니다. 이 서명은 헤더의 인코딩값과, 정보의 인코딩값을 합친후 주어진 비밀키(보통 따로 저장해서 임포트해서 쓴다)로 해쉬를 하여 생성합니다.

이렇게 만든 해쉬를, base64 형태로 나타내면 됩니다 (문자열을 인코딩 하는게 아닌 hex → base64 인코딩을 해야합니다)

![signature영역](https://blog.martinwork.co.kr/images/jwt/jwt05.png)

위에서 계속 나왔던 이미지파일들 https://jwt.io/ 의 디버거이다. (JWT.IO 는 브라우저 상에서 JWT 토큰을 검증하고 생성 할 수 있게 해주는 디버거 서비스입니다)

위의 정보값을 넣어보고 테스트 할 수 있으며 하단의 텍스트가 파란색으로 Signature Verified 라고 뜨면 JWT 토큰이 검증되었다는 것 입니다.

![jWT 검증](https://velopert.com/wp-content/uploads/2016/12/Untitled-4-950x767.png)

## JWT Token 은 무결성이 보장된다.

공식 홈페이지에 메인에서 테스트를 해보면 예시로 보여주고 있는 JWT Token 의 secret 키를 하나라도 입력을 하게 되면 JWT Token 에서 Signature 영역의 글자가 바로 바뀌는 것을 알 수 있다. 이처럼 JWT Token 은 변조가 되었을 때, 바로 알아차릴 수가 있다.

# Refresh Token

Access Token(JWT)를 통한 인증 방식의 문제는 만일 제 3자에게 탈취당할 경우 보안에 취약하다는 점입니다.

유효기간이 짧은 Token의 경우 그만큼 사용자는 로그인을 자주 해서 새롭게 Token을 발급받아야 하므로 불편합니다. 그러나 유효기간을 늘리자면, 토큰을 탈취당했을 때 보안에 더 취약해지게 됩니다.

이때 “그러면 유효기간을 짧게 하면서 좋은 방법이 있지는 않을까?”라는 질문의 답이 바로 "Refresh Token"입니다.

Refresh Token은 Access Token과 똑같은 형태의 JWT입니다. 처음에 로그인을 완료했을 때 Access Token과 동시에 발급되는 Refresh Token은 긴 유효기간을 가지면서, Access Token이 만료됐을 때 새로 발급해주는 열쇠가 됩니다(여기서 만료라는 개념은 그냥 유효기간을 지났다는 의미입니다.)

사용 예를 간단히 들어보겠습니다. Refresh Token의 유효기간은 2주, Access Token의 유효기간은 1시간이라 하겠습니다. 사용자는 API 요청을 신나게 하다가 1시간이 지나게 되면, 가지고 있는 Access Token은 만료됩니다. 그러면 Refresh Token의 유효기간 전까지는 Access Token을 새롭게 발급받을 수 있습니다.

- Access Token은 탈취당하면 정보가 유출되는건 동일합니다. 다만 짧은 유효기간 안에만 사용이 가능하기에 더 안전하다는 의미입니다.

* Refresh Token의 유효기간이 만료됐다면, 사용자는 새로 로그인해야 합니다. Refresh Token도 탈취될 가능성이 있기 때문에 적절한 유효기간 설정이 필요해보입니다(보통 2주로 많이 잡더군요)

# Access Token + Refresh Token 인증 과정

![](https://t1.daumcdn.net/cfile/tistory/99DB8C475B5CA1C936)

1. 사용자가 ID , PW를 통해 로그인합니다.
2. 서버에서는 회원 DB에서 값을 비교합니다(보통 PW는 일반적으로 암호화해서 들어갑니다)
3. ~4. 로그인이 완료되면 Access Token, Refresh Token을 발급합니다. 이때 일반적으로 회원DB에 Refresh Token을 저장해둡니다.
4. 사용자는 Refresh Token은 안전한 저장소에 저장 후, Access Token을 헤더에 실어 요청을 보냅니다.
5. ~7. Access Token을 검증하여 이에 맞는 데이터를 보냅니다.
6. 시간이 지나 Access Token이 만료됐다고 보겠습니다.
7. 사용자는 이전과 동일하게 Access Token을 헤더에 실어 요청을 보냅니다.
8. ~11. 서버는 Access Token이 만료됨을 확인하고 권한없음을 신호로 보냅니다.

9. 사용자는 Refresh Token과 Access Token을 함께 서버로 보냅니다.
10. 서버는 받은 Access Token이 조작되지 않았는지 확인한후, Refresh Token과 사용자의 DB에 저장되어 있던 Refresh Token을 비교합니다. Token이 동일하고 유효기간도 지나지 않았다면 새로운 Access Token을 발급해줍니다.
11. 서버는 새로운 Access Token을 헤더에 실어 다시 API 요청을 진행합니다.

- Access Token 만료가 될 때마다 계속 과정 9~11을 거칠 필요는 없습니다.  
  사용자(프론트엔드)에서 Access Token의 Payload를 통해 유효기간을 알 수 있습니다. 따라서 프론트엔드 단에서 API 요청 전에 토큰이 만료됐다면 바로 재발급 요청을 할 수도 있습니다.

## 큰 장점

기존의 Access Token만 있을 때보다 안전합니다.

## 단점

1. 구현이 복잡합니다. 검증 프로세스가 길기 때문에 자연스레 구현하기 힘들어졌습니다(프론트엔드, 서버 모두)
2. Access Token이 만료될 때마다 새롭게 발급하는 과정에서 생기는 HTTP 요청 횟수가 많습니다. 이는 서버의 자원 낭비로 귀결됩니다.
