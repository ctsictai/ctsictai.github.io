---
title: Data Structure & Algorithm
date: "2019-11-17T21:30:03.284Z"
template: "post"
draft: false
slug: "/posts/datastructure/"
category: "Python/data structure/algorithm"
tags: -"Python/data structure"

description: "Data Structure & Algorithm"
socialImage: "/media/gutenberg.jpg"
---

# 자료구조와 알고리즘

데이터를 저장하는 스트럭쳐
자료구조를 잘 선택해야 코드의 복잡성을 줄일 수 있다.

# 배열

- 순서가 있는 데이터를 저장할 때 유리
- 물리적 주소가 순서대로 저장되는 구조
- 메모리를 할당하기 위해 어느정도 빈 물리적 공간을 확보해야 한다.
- 시간복잡도 O(N) - 배열의 길이 만큼 찾는 시간이 늘어나는 구조이다.

![](https://t1.daumcdn.net/cfile/tistory/992BD84F5B230A4425)

### 자료 액세스 시 주소를 얻는 방식 :

배열의 시작주소 + 자료형의크기×인덱스값의 주소를 액세스

ex)

- sample[3]의 값을 액세스 하는 경우
- 배열의시작주소(1000) + int의크기(4) × 인덱스값(3) = 1012
- 1012의 주소에 있는 값 액세스 : 44

## 장점

1. 인덱스를 통해 모든 데이터에 직접 액세스하기 때문에 액세스 속도가 빠르다.
2. 포인터 등 부가적인 정보가 없어 기록 밀도가 1이다.(메타데이터가 없다. - ex) key)
3. 가장 간단하며 사용하기 쉽다.

## 단점

1. 삽입, 삭제가 어렵다(삽입, 삭제가 어렵기 때문에 삽입삭제가 없는 경우에만 사용한다.)

- 중간에 데이터를 삽입하거나 삭제할 경우
  뒤의 데이터를 모두 한칸씩 당겨와야 하기 때문에 부하가 많이 걸린다.
  (만약 삭제하지 않고 그냥 둔다면 인덱스를 이용한 주소값 계산을 할 수 없기 때문에 자료를 연속된 공간에 두기 위해 이동이 필요함)

- 예를들어 위의 예제에서 sample[2]를 삭제하면 그 뒤의 값들을 한칸씩 당겨와야한다.
  ![](https://t1.daumcdn.net/cfile/tistory/997BDF375B230ED928)
  ![](https://t1.daumcdn.net/cfile/tistory/99B8E5375B230EE732)

2. 메모리에 종속적이다
   연속된 메모리에 저장 되므로 종속적일 수 밖에 없다.

3. 메모리 사이즈가 부족해진 경우에 큰 공수가 필요하다

> re-sizing기법 사용

    - 지금 있는 메모리를 copy한 후 더 큰 빈 메모리 공간을 확보하여 순서대로 자료를 저장하는 방법
    - 공수가 매우 많이 필요한 작업이다.
    - 이 것 때문에 배열구조를 만들기전에 미리 빈 메모리 공간을 예측하여 확보하는 것이 좋다

# 튜플(python)

- 배열에서와는 다르게 변경이 불가능한 자료구조이다.
- 그래서 변경이 없는 좌표 데이터를 나타내기 좋은 자료구조
- 배열과 같이 인덱싱 사용 가능하다.
- 튜플의 시간복잡도는 배열과 같게 O(N)이다.
- 튜플이 없다면 클래스로 선언해서 클래스 호출로 가능(javascript)
- 2개 ~ 5개 값을 리턴할 때 사용하기 적절하다.(너무 많으면 오히려 좋지 않다)
- named_tuple - 인덱스에 key값을 줄 수 있음
- test code에 튜플 사용할 수 있으면 좋다

# set

- 순서가 없다
- 중복을 허용하지 않는다
- 집합 자료를 표현하는데 적합하다
- 시간복잡도 O (log N)
- set 중복을 어떤 로직으로 없앨까???
- 값을 치환한다 왜 할까??

> clss (1,1) == clss(1,1) 는 맞을까?

- 클래스는 부모 객체 object가 있어서 아무것도 정해놓지 않으면 부모 클래스인 object를 상속받아서 default 값으로 주소값으로 비교한다.

- 그래서 clss (1,1) == clss(1,1) 는 다르다 - 주소값이 다르기 때문에 그래서 문맥상 같다라는 것을 표현하기 위해 클래스의 함수를 정의하여 로직상으로 같게 한다.

- set에서는 특정 값에 대해서 hash 값으로 변환하여 hash값에 맞는 메모리 주소에 할당하기 때문에 특정 값이 중복으로 들어온다면 똑같은 hash 값을 가져서 새로운 값으로 값이 치환된다.
