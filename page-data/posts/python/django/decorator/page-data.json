{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/python/django/decorator","result":{"data":{"markdownRemark":{"id":"2035bd03-860e-5df6-b0be-c45ebf766854","html":"<h1 id=\"데코레이터란\"><a href=\"#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0%EB%9E%80\" aria-label=\"데코레이터란 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데코레이터란?</h1>\n<p>함수(메서드)를 장식하는 개념으로 함수 앞뒤에 기능을 추가해서 손쉽게 함수를 활용할 수 있는 기법이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Calc:\n    @staticmethod    # 데코레이터\n    def add(a, b):\n        print(a + b)</code></pre></div>\n<h2 id=\"그러면-왜-쓸까\"><a href=\"#%EA%B7%B8%EB%9F%AC%EB%A9%B4-%EC%99%9C-%EC%93%B8%EA%B9%8C\" aria-label=\"그러면 왜 쓸까 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그러면 왜 쓸까?</h2>\n<p>함수나 클래스의 메서드는 한 함수에 한 기능을 넣는 것이 좋다.<br>\n(Unit test를 생각한다면 더더욱 함수 하나에 한 기능을 넣어야 한다.)</p>\n<p>그런데 한 함수에 한 기능을 넣기에는 애매한 경우가 있다.<br>\n혹은 한가지 기능에 간단한 로직을 첨가하는 것이 좀 더 좋아지는 경우<br>\n한 기능을 여러 메서드나 함수에서 계속적으로 사용할 때 함수마다 기능을 넣는 것은 계속 같은 코드가 중복되는 문제가 발생한다.</p>\n<p>이럴 때 사용하는 것이 데코레이터이다.</p>\n<h2 id=\"데코레이터-형태-설명\"><a href=\"#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%98%95%ED%83%9C-%EC%84%A4%EB%AA%85\" aria-label=\"데코레이터 형태 설명 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데코레이터 형태 설명</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def trace(func):                             # 호출할 함수를 매개변수로 받음\n    def wrapper():                           # 호출할 함수를 감싸는 함수\n        print(func.__name__, &#39;함수 시작&#39;)    # __name__으로 함수 이름 출력\n        func()                               # 매개변수로 받은 함수를 호출\n        print(func.__name__, &#39;함수 끝&#39;)\n    return wrapper                           # wrapper 함수 반환\n    # 함수안에서 함수를 만들고 반환하는 클로저 개념\n\ndef hello():\n    print(&#39;hello&#39;)</code></pre></div>\n<blockquote>\n<p>결과</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">trace_hello = trace(hello)    # 데코레이터에 호출할 함수를 넣음\ntrace_hello()                 # 반환된 함수를 호출\n\nhello 함수 시작\nhello\nhello 함수 끝</code></pre></div>\n<h2 id=\"데코레이터의-일반-형태\"><a href=\"#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%9D%BC%EB%B0%98-%ED%98%95%ED%83%9C\" aria-label=\"데코레이터의 일반 형태 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데코레이터의 일반 형태</h2>\n<p>데코레이터 앞에 @를 붙여준다. 그리고 데코레이터를 적용할 함수 앞 줄에 꼭 입력한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@데코레이터\ndef 함수이름():\n    코드</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def trace(func):                             # 호출할 함수를 매개변수로 받음\n    def wrapper():                           # 호출할 함수를 감싸는 함수\n        print(func.__name__, &#39;함수 시작&#39;)    # __name__으로 함수 이름 출력\n        func()                               # 매개변수로 받은 함수를 호출\n        print(func.__name__, &#39;함수 끝&#39;)\n    return wrapper                           # wrapper 함수 반환\n    # 함수안에서 함수를 만들고 반환하는 클로저 개념\n\n@trace               # @데코레이터\ndef hello():\n    print(&#39;hello&#39;)</code></pre></div>\n<h2 id=\"가변-인수를-가지는-데코레이터\"><a href=\"#%EA%B0%80%EB%B3%80-%EC%9D%B8%EC%88%98%EB%A5%BC-%EA%B0%80%EC%A7%80%EB%8A%94-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0\" aria-label=\"가변 인수를 가지는 데코레이터 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가변 인수를 가지는 데코레이터</h2>\n<p>매개변수(인수)가 고정되지 않은 함수를 처리할 때 wrapper 함수를 가변 인수 함수로 만들면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def trace(func):                     # 호출할 함수를 매개변수로 받음\n    def wrapper(*args, **kwargs):    # 가변 인수 함수로 만듦\n        res = func(*args, **kwargs)  # func에 args, kwargs를 언패킹하여 넣어줌\n        print(&#39;{0}(args={1}, kwargs={2}) -&gt; {3}&#39;.format(func.__name__, args, kwargs, r))\n                                     # 매개변수와 반환값 출력\n        return res                   # func의 반환값을 반환\n    return wrapper                   # wrapper 함수 반환\n\n@trace                   # @데코레이터\ndef get_max(*args):      # 위치 인수를 사용하는 가변 인수 함수\n    return max(args)\n\nprint(get_max(10, 20))\n&gt; get_max(args=(10, 20), kwargs={}) -&gt; 20\n&gt; 20</code></pre></div>\n<h2 id=\"매개변수인자가-존재하는-데코레이터\"><a href=\"#%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EC%9D%B8%EC%9E%90%EA%B0%80-%EC%A1%B4%EC%9E%AC%ED%95%98%EB%8A%94-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0\" aria-label=\"매개변수인자가 존재하는 데코레이터 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>매개변수(인자)가 존재하는 데코레이터</h2>\n<p>데코레이터는 값을 지정해서 동작을 바꿀 수 있습니다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def is_multiple(x):              # 데코레이터가 사용할 매개변수를 지정\n    def real_decorator(func):    # 호출할 함수를 매개변수로 받음\n        def wrapper(a, b):       # 호출할 함수의 매개변수와 똑같이 지정</code></pre></div>\n<p>일반적인 데코레이터를 만들 때 함수 안에 함수를 하나만 만들었습니다. 하지만 매개변수가 있는 데코레이터를 만들 때는 함수를 하나 더 만들어야 합니다.</p>\n<p>먼저 is<em>multiple 함수를 만들고 데코레이터가 사용할 매개변수 x를 지정합니다.(매개변수를 지정할 함수) 그리고 is</em>multiple 함수 안에서 실제 데코레이터 역할을 하는 real<em>decorator(일반적인 데코레이터 함수)를 만듭니다. 즉, 이 함수에서 호출할 함수를 매개변수로 받습니다. 그다음에 real</em>decorator 함수 안에서 wrapper 함수를 만들어주면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def is_multiple(x):              # 데코레이터가 사용할 매개변수를 지정\n    def real_decorator(func):    # 호출할 함수를 매개변수로 받음\n        def wrapper(a, b):       # 호출할 함수의 매개변수와 똑같이 지정\n            res = func(a, b)     # func를 호출하고 반환값을 변수에 저장\n            if res % x == 0:     # func의 반환값이 x의 배수인지 확인\n                print(&#39;{0}의 반환값은 {1}의 배수입니다.&#39;.format(func.__name__, x))\n            else:\n                print(&#39;{0}의 반환값은 {1}의 배수가 아닙니다.&#39;.format(func.__name__, x))\n            return res           # func의 반환값을 반환\n        return wrapper           # wrapper 함수 반환\n    return real_decorator        # real_decorator 함수 반환</code></pre></div>\n<p>여기서는 real_decorator, wrapper 함수를 두 개 만들었으므로 함수를 만든 뒤에 return으로 두 함수를 반환해줍니다.</p>\n<p>데코레이터를 사용할 때는 데코레이터에 ( )(괄호)를 붙인 뒤 인수를 넣어주면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@데코레이터(인수)\ndef 함수이름():\n    코드</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@is_multiple(3)     # @데코레이터(인수)\ndef add(a, b):\n    return a + b\nprint(add(10, 20))\n&gt; add의 반환값은 3의 배수입니다.\n&gt; 30</code></pre></div>\n<h3 id=\"-데코레이터-여러개-지정하기\"><a href=\"#-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%EC%97%AC%EB%9F%AC%EA%B0%9C-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\" 데코레이터 여러개 지정하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>※ 데코레이터 여러개 지정하기</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@데코레이터1\n@데코레이터2\ndef 함수이름():\n    코드</code></pre></div>\n<p>데코레이터가 위에서부터 차례대로 실행된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def decorator1(func):\n    def wrapper():\n        print(&#39;decorator1&#39;)\n        func()\n    return wrapper\n\ndef decorator2(func):\n    def wrapper():\n        print(&#39;decorator2&#39;)\n        func()\n    return wrapper\n\n# 데코레이터를 여러 개 지정\n@decorator1\n@decorator2\ndef hello():\n    print(&#39;hello&#39;)\n\nhello()\n\ndecorator1\ndecorator2\nhello</code></pre></div>\n<h1 id=\"실제-데코레이터-생성-예시\"><a href=\"#%EC%8B%A4%EC%A0%9C-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%EC%83%9D%EC%84%B1-%EC%98%88%EC%8B%9C\" aria-label=\"실제 데코레이터 생성 예시 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실제 데코레이터 생성 예시</h1>\n<p>로그인 시 JWT 토큰을 발급하고 특정 페이지를 조회하거나 페이지를 게시할 때 로그인 유저인지 확인하기 위한 데코레이터</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def login_decorator(func):\n    def wrapper(self, request, *args, **kwargs):\n\n        if &quot;Authorization&quot; not in request.headers:\n            return JsonResponse({&quot;ERROR_CODE&quot;:&quot;INVALID_LOGIN&quot;}, status=401)             # 웹페이지에서 기존에 발급받았던 토큰을 request.header에 실어서 보낸다. 이 때 아무것도 없다면 로그인이 안되있다고 판단하고 에러를 리턴한다.\n\n        encode_token = request.headers[&quot;Authorization&quot;]                                 # 프론트에서 보낸 토큰\n\n        try:\n            data = jwt.decode(encode_token, SECRET[&#39;secret&#39;], algorithm=&#39;HS256&#39;)\n            user = User.objects.get(id = data[&quot;user_id&quot;])                               # 토큰값에 있는 user_id와 user DB table에 있는 user_id와 비교\n            request.user = user                                                         # 프론트엔드에게 받은 request.user에 3번의 자료 저장 =&gt;프론트엔드에게 전달해주기 전 준비과정\n        except jwt.DecodeError:                                                         # 토큰값이 decode가 안될 시에 에러 리턴\n            return JsonResponse({&quot;ERROR_CODE&quot; : &quot;INVALID_TOKEN&quot;}, status = 401)\n\n        except User.DoesNotExist:                                                       # user가 존재하지 않는 경우 에러 리턴\n            return JsonResponse({&quot;ERROR_CODE&quot; : &quot;UNKNOWN_USER&quot;}, status = 401)\n\n        return func(self, request, *args, **kwargs)                                     # 4번에 저장된 request를 데코레이터 리턴\n=&gt; 데코레이터종료 및 프론트엔드에게 해당 유저의 정보를 리턴\n\n    return wrapper</code></pre></div>\n<h3 id=\"실제-데코레이터-적용-예시\"><a href=\"#%EC%8B%A4%EC%A0%9C-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%EC%A0%81%EC%9A%A9-%EC%98%88%EC%8B%9C\" aria-label=\"실제 데코레이터 적용 예시 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실제 데코레이터 적용 예시</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@login_decorator                                     # 데코레이터 함수 적용\ndef get(self, request):                              # 로그인 데코레이터 적용시킬 함수\n    user = request.user                              # request.user가 로그인 데코레이터에서 받은 변수값\n    data = [{\n        &quot;user_name&quot; : user.user_name,\n        &quot;user_email&quot; : user.email\n    }]\n    return JsonResponse({&quot;data&quot;: data}, status=200)</code></pre></div>","fields":{"slug":"/posts/python/django/decorator","tagSlugs":["/tag/python-decorator-login-required/"]},"frontmatter":{"date":"2020-01-08T23:30:03.284Z","description":"decorator example","tags":["Python, Decorator, Login_required"],"title":"Decorator","socialImage":"/media/gutenberg.jpg"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/python/django/decorator"}}}