{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/OAuth","result":{"data":{"markdownRemark":{"id":"610459ce-caa1-5a4d-8cf3-428c198c9473","html":"<h1 id=\"oauth-개념\"><a href=\"#oauth-%EA%B0%9C%EB%85%90\" aria-label=\"oauth 개념 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OAuth 개념</h1>\n<p>OAuth 2.0은 외부 서비스(third-party application)의 인증 및 권한부여를 관리하는 범용 프레임워크 입니다.</p>\n<p>OAuth 기반 서비스의 API를 호출을 할 때에는, HTTP 헤더에 access token을 포함하여 요청을 보내게 됩니다. 서비스는 access token을 검사하면서 이 요청이 유효한지 판단하여 적절한 결과를 응답합니다.</p>\n<p>사용자 입장에선 OAuth의 권한 요청 절차는 access token을 획득하는 것이 가장 주요한 목적이라 할 수 있고, 서비스 제공자 입장에선 인증된 사용자에게 access token을 발급하는 것이 가장 중요한 일이라 할 수 있습니다.</p>\n<p>결국 소셜 로그인 API를 만들기 위한 과정이다.</p>\n<p>여기서 중요한 것은 소셜 로그인 기능을 넣더라도 결국은 세션/쿠키 방식이나 토큰을 활용해 인증을 거쳐야 한다는 것이다.</p>\n<h2 id=\"oauth에서-중요한-용어들\"><a href=\"#oauth%EC%97%90%EC%84%9C-%EC%A4%91%EC%9A%94%ED%95%9C-%EC%9A%A9%EC%96%B4%EB%93%A4\" aria-label=\"oauth에서 중요한 용어들 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OAuth에서 중요한 용어들</h2>\n<ul>\n<li>Resource Owner : User, 즉 일반 사용자를 칭합니다.</li>\n<li>\n<p>Client : 우리가 관리하는 어플리케이션 서버</p>\n<ul>\n<li>User와 혼동될 수 있는데 아니다!!! - 헷갈리지말자</li>\n<li>프론트 서버와 백엔드 서버 둘 다 포함하는 개념이다.</li>\n</ul>\n</li>\n<li>Authorization Server : 권한을 관리하는 서버입니다. Access Token, Refresh Token을 발급, 재발급 해주는 역할을 합니다.(프론트에서 받은 토큰 발급 프로세스를 진행하는 곳)</li>\n<li>Resource Server : OAuth2.0을 관리하는 서버(Google, Facebook, Naver 등) 의 자원을 관리하는 서버입니다. 주의할 점은 우리가 만드는 서버의 자원을 관리하는 곳이 아닙니다. Oauth 2.0 관리 서버의 자체 API를 의미합니다.</li>\n<li>\n<p>Authorization Code : 권한 서버에서 인증을 받아 권한을 받아 Token 발급 받을 때 중간과정으로 권한 코드를 받아 클라이언트(우리가 관리하는 서버)에 보내고 클라이언트가 이걸 권한 서버에 보내서 Token을 받는다. (한번 더 보안벽이 있다고 이해하였다.)</p>\n<ul>\n<li>facebook, google 등에서 사용되는 방법이다.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/9945F13F5B6EECC02A\"></p>\n<ol>\n<li>Resource Owner(사용자)가 Client(우리 서버)에게 인증 요청을 합니다.</li>\n<li>Client는 Authorization Request를 통해 Resource Owner에게 인증할 수단(ex Facebook, Google 로그인 url)을 보냅니다.</li>\n<li>Resource Owner는 해당 Request를 통해 인증을 진행하고 인증을 완료했다는 신호로 Authorization Grant를 url에 실어 Client에게 보냅니다.</li>\n<li>Client는 해당 권한증서(Authorization Grant)를 Authorization Server에 보냅니다.</li>\n<li>Authorization Server는 권한증서를 확인 후, 유저가 맞다면 Client에게 Access Token, Refresh Token, 그리고 유저의 프로필 정보(id 포함) 등을 발급해줍니다.</li>\n<li>Client는 해당 Access Token을 DB에 저장하거나 Resource Owner에게 넘깁니다.</li>\n<li>Resource Owner(사용자)가 Resource Server에 자원이 필요하면, Client는 Access Token을 담아 Resource Server에 요청합니다.</li>\n<li>Resource Server는 Access Token이 유효한지 확인 후, Client에게 자원을 보냅니다.</li>\n<li>만일 Access Token이 만료됐거나 위조되었다면, Client는 Authorization Server에 Refresh Token을 보내 Access Token을 재발급 받습니다.</li>\n<li>그 후 다시 Resource Server에 자원을 요청합니다.</li>\n<li>만일 Refresh token도 만료되었을 경우, Resource Owner는 새로운 Authorization Grant를 Client에게 넘겨야합니다. (이는 다시 사용자가 다시 로그인 하라는 말입니다.)</li>\n</ol>","fields":{"slug":"/posts/OAuth","tagSlugs":["/tag/o-auth-2-0/"]},"frontmatter":{"date":"2020-01-14T23:30:03.284Z","description":"OAuth2.0","tags":["OAuth2.0"],"title":"OAuth2.0","socialImage":"/media/gutenberg.jpg"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/OAuth"}}}