{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/python-part9/","webpackCompilationHash":"44e8c8ab14b8a94efcdc","result":{"data":{"markdownRemark":{"id":"8c9f45d5-cbe0-563d-a331-b4fbd3ba178f","html":"<h1 id=\"decorator\"><a href=\"#decorator\" aria-label=\"decorator permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Decorator</h1>\n<p><strong>@decorator명</strong> —> 데코레이터 선언</p>\n<p>함수 앞뒤에 기능을 추가해서 손쉽게 함수를 활용할 수 있는 기법<br>\n여러 함수에 동일한 기능을 @데코레이터 하나로 간편하게 추가할 수 있다.<br>\n중첩 함수를 만드는 데 있어서 좀 더 편리한 기능이다.<br>\n중첩 함수를 만드는데 있어서 그 중첩 함수를 글로벌하게 데코레이터로써 쓸 수 있다.</p>\n<ul>\n<li>\n<p>대표적인 데코레이터</p>\n<ol>\n<li>@staticmethod / @classmethod 등 class에서 메소드에 선언할 때 많이 씀</li>\n<li>@auth 웹 페이지 상에서 signin 된 상태를 증명하기 위한 인가 증명에서 많이 쓰인다.</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"데코레이터-작성하기\"><a href=\"#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0\" aria-label=\"데코레이터 작성하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데코레이터 작성하기</h2>\n<blockquote>\n<p>def datetime<em>decorator(func): # &#x3C;--- datetime</em>decorator 는 데코레이터 이름, func 가 이 함수 안에 넣을 함수가 됨</p>\n<blockquote>\n<p>def wrapper(): # &#x3C;--- 호출할 함수를 감싸는 함수</p>\n<blockquote>\n<p>print (‘time ’ + str(datetime.datetime.now())) # &#x3C;--- 함수 앞에서 실행할 내용<br>\nfunc() # &#x3C;--- 함수(데코레이터 적용시킬)<br>\nprint (datetime.datetime.now()) # &#x3C;--- 함수 뒤에서 실행할 내용\nreturn wrapper # &#x3C;--- closure 함수로 만든다</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>기본 구조는 함수를 인자로 불러와서 그 함수를 함수안에서 사용한다는 개념이다.</p>\n<ul>\n<li>print (‘time ’ + str(datetime.datetime.now())) 부분은\n데코레이터 적용할 함수 전에 실행할 로직이 들어가는 부분</li>\n<li>print (datetime.datetime.now()) 부분은 데코레이터 적용할 함수의 로직이 끝난 뒤 실행할 로직이 들어가는 부분</li>\n</ul>\n<p>실행할 함수 앞 뒤로 감싼 로직을 실행한다는 의미에서 wrapper라고 통상적으로 함수명을 많이 짓는다.</p>\n<h2 id=\"매개변수와-반환값이-있는-데코레이터\"><a href=\"#%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EC%99%80-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0\" aria-label=\"매개변수와 반환값이 있는 데코레이터 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>매개변수와 반환값이 있는 데코레이터</h2>\n<p>def trace(func): # 호출할 함수를 매개변수로 받음</p>\n<blockquote>\n<p>def wrapper(a, b): # 호출할 함수 add(a, b)의 매개변수와 똑같이 지정</p>\n<blockquote>\n<p>r = func(a, b) # func에 매개변수 a, b를 넣어서 호출하고 반환값을 변수에 저장<br>\nprint(‘{0}(a={1}, b={2}) -> {3}‘.format(func.<strong>name</strong>, a, b, r)) # 매개변수와 반환값 출력<br>\nreturn r # func의 반환값을 반환</p>\n</blockquote>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return wrapper        # wrapper 함수 반환</code></pre></div>\n<p>@trace # @데코레이터<br>\ndef add(a, b): # 매개변수는 두 개</p>\n<blockquote>\n<p>return a + b # 매개변수 두 개를 더해서 반환</p>\n</blockquote>\n<p>print(add(10, 20))</p>\n<p>이렇게 되면 결과값은</p>\n<p>add(a=10, b=20) -> 30<br>\n30</p>\n<p>이 데코레이터와 함수에서는 데코레이터 함수 내에서 함수를 호출해 변수에 저장 후에 변수를 return하는 방식으로 로직이 구성되었다.<br>\n그렇기 때문에 print가 먼저 실행되고 add 함수의 return이 나중에 실행된 것이다.</p>\n<ul>\n<li><strong>순서와 함수 호출 여부를 잘 봐야 한다</strong></li>\n</ul>\n<h2 id=\"가변인자-매개변수와-반환값이-있는-데코레이터\"><a href=\"#%EA%B0%80%EB%B3%80%EC%9D%B8%EC%9E%90-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EC%99%80-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0\" aria-label=\"가변인자 매개변수와 반환값이 있는 데코레이터 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가변인자 매개변수와 반환값이 있는 데코레이터</h2>\n<p>위의 과정은 매개변수가 고정되어 있는 함수이다.<br>\n매개변수(인수)가 고정되지 않은 함수는 어떻게 처리할까요? 이때는 wrapper 함수를 가변 인수 함수로 만들면 됩니다.</p>\n<p>def trace(func): # 호출할 함수를 매개변수로 받음</p>\n<blockquote>\n<p>def wrapper(*args, **kwargs): # 가변 인수 함수로 만듦</p>\n<blockquote>\n<p>r = func(*args, **kwargs) # func에 args, kwargs를 언패킹하여 넣어줌<br>\nprint(‘{0}(args={1}, kwargs={2}) -> {3}‘.format(func.<strong>name</strong>, args, kwargs, r)) # 매개변수와 반환값 출력<br>\nreturn r # func의 반환값을 반환</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>return wrapper # wrapper 함수 반환</p>\n</blockquote>\n<p>@trace # @데코레이터<br>\ndef get_max(*args): # 위치 인수를 사용하는 가변 인수 함수</p>\n<blockquote>\n<p>return max(args)</p>\n</blockquote>\n<p>@trace # @데코레이터<br>\ndef get_min(**kwargs): # 키워드 인수를 사용하는 가변 인수 함수</p>\n<blockquote>\n<p>return min(kwargs.values())</p>\n</blockquote>\n<p>결과값<br>\nprint(get<em>max(10, 20))<br>\nprint(get</em>min(x=10, y=20, z=30))</p>\n<p>get<em>max(args=(10, 20), kwargs={}) -> 20<br>\n20<br>\nget</em>min(args=(), kwargs={‘x’: 10, ‘y’: 20, ‘z’: 30}) -> 10<br>\n10</p>\n<p>고정 인자 함수와의 차이점은 wrapper 함수의 인자가 가변인자로 바뀐다는 점이다.</p>\n<h2 id=\"method-decorator\"><a href=\"#method-decorator\" aria-label=\"method decorator permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Method Decorator</h2>\n<p>클래스메서드나 정적메서드 데코레이터 사용하듯이 클래스의 메소드에 사용되어지는 데코레이터</p>\n<p>def h1_tag(function):</p>\n<blockquote>\n<p>def func_wrapper(self, *args, **kwargs): # &#x3C;--- self 를 무조건 첫 파라미터로 넣어야 메서드에 적용가능(클래스에 적용하기 위한)</p>\n<blockquote>\n<p>return “{0}“.format(function(self, *args, **kwargs)) # &#x3C;--- function 함수에도 self 를 넣어야 함</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>return func_wrapper</p>\n</blockquote>\n<h3 id=\"클래스-선언시-메서드에-데코레이터-적용하기\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%84%A0%EC%96%B8%EC%8B%9C-%EB%A9%94%EC%84%9C%EB%93%9C%EC%97%90-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"클래스 선언시 메서드에 데코레이터 적용하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스 선언시 메서드에 데코레이터 적용하기</h3>\n<ul>\n<li>@staticmethod / @classmethod와 비슷</li>\n</ul>\n<p>class Person:</p>\n<blockquote>\n<p>def <strong>init</strong>(self, first<em>name, last</em>name):</p>\n<blockquote>\n<p>self.first<em>name = first</em>name<br>\nself.last<em>name = last</em>name</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>@h1<em>tag<br>\ndef get</em>name(self):</p>\n<blockquote>\n<p>return self.first<em>name + ’ ’ + self.last</em>name – 리턴값 1개!- 위에서 첫번째 인자 {0}으로 인식되어서 들어감</p>\n</blockquote>\n</blockquote>\n<p>데코레이터 적용 확인해보기<br>\ndavelee = Person(‘Lee’, ‘Dave’)<br>\nprint(davelee.get_name())</p>\n<ul>\n<li>Lee Dave</li>\n</ul>\n<h2 id=\"파라미터를-가지고-있는-데코레이터\"><a href=\"#%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A5%BC-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%9E%88%EB%8A%94-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0\" aria-label=\"파라미터를 가지고 있는 데코레이터 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파라미터를 가지고 있는 데코레이터</h2>\n<p>def name<em>decorator(char): - #char는 name</em>decorator에 적용될 파라미터 -파라미터 적용을 위한 함수</p>\n<blockquote>\n<p>def real_deco(func): - #실제 데코레이터 함수 적용 (func) 적용할 함수 인자로 불러</p>\n<blockquote>\n<p>def wrapper(): - # 감쌀꺼 func이 greetings() – none param —> wrapper no param # 혹 적용할 함수에 인자가 있으면 같이 적용해주자</p>\n<blockquote>\n<p>return func() + char # func에 데코에서 받은 인자 char를 더해줌(둘 다 str type)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>return wrapper - 리턴 (wrapper 함수 자체를)</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>return real_deco – 최종 리턴 – 이래야 함수 실행됨 (함수자체를 리턴해버리니까)</p>\n</blockquote>\n<p>@name_decorator(“정우성”) – 데코에 파라미터 char가 적용된 모습\ndef greeting():</p>\n<blockquote>\n<p>return “Hello, ”</p>\n</blockquote>\n<p>결과값<br>\nprint(greeting())<br>\nHello, 정우성</p>","fields":{"slug":"/posts/python-part9/","tagSlugs":["/tag/python/"]},"frontmatter":{"date":"2019-10-22T23:30:03.284Z","description":"Decorator","tags":["Python/"],"title":"Python Apprenticeship Study Part.9","socialImage":"/media/gutenberg.jpg"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/python-part9/"}}}