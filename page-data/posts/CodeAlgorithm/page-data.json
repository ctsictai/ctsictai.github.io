{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/CodeAlgorithm/","result":{"data":{"markdownRemark":{"id":"54223ecd-aee1-5967-bb0b-46388c5d7b95","html":"<h1 id=\"binary-search\"><a href=\"#binary-search\" aria-label=\"binary search permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Binary Search</h1>\n<p>target을 찾는 방법 중 하나이다.</p>\n<p>가장 쉬운 방법은 list를 처음부터 끝까지 target 값을 찾는 것이다.</p>\n<p>근데 이 방법은 딱 봐도 너무 무식하고 공수가 많이 든다는 것을 알 수 있다.</p>\n<p>그러면 좀 더 효율적으로 할 수 있는 논리적 방법이 없을까??</p>\n<p>많은 찾아야 할 값들 중에서 대강 스캔을 해본 뒤 정말 관계가 없어보이거나 필요없어 보이는 부분을 과감히 제외한다. 그리고 나머지 부분에서 내가원하는 target을 찾는 방법을 쉽게 떠올릴 수 있다.</p>\n<p>일반적으로도 내가 해야되는 수많은 선택지 중에서 일부를 과감히 버리게 된다.</p>\n<p>이걸 단순 논리적으로 접근한 것이 바로 이진탐색(Binary Search)이다.</p>\n<h2 id=\"1-이진-탐색이란\"><a href=\"#1-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89%EC%9D%B4%EB%9E%80\" aria-label=\"1 이진 탐색이란 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 이진 탐색이란?</h2>\n<p>탐색할 리스트의 요소 개수를 절반으로 줄여가면서 탐색을 하는 방법을 말한다.</p>\n<p>다만 이진 탐색(binary search)은 오름 차순으로 정렬된 배열에만 적용할 수 있다는 단점이 있습니다.</p>\n<p>이진 탐색에서 중요한 요소는 low index와 high 혹은 max index와 반을 잘라 낼 수 있는 mid index이다.</p>\n<p>크기가 n 인 리스트 data에서 target 이라는 특정 요소를 찾아낸다고 가정했을 때, 이진 탐색의 절차는 다음과 같다.</p>\n<ol>\n<li>low =0, high = n−1 로 초기화 합니다.</li>\n<li>mid 는 (log + high) 를 2 로 나눈 몫으로 결정합니다.</li>\n<li>data[mid] 와 target 이 서로 같으면 목적을 달성했으므로 탐색을 종료합니다.</li>\n<li>만약 target &#x3C; data[mid] 이면 high = mid-1 로 업데이트 한 후, 2번으로 돌아갑니다. 만약 target > data[mid] 라면 low = mid+1 로 업데이트 한 후, 2번으로 돌아갑니다.</li>\n</ol>\n<p>4번을 자세히 보면 2번으로 계속 되돌아 가는 걸 볼 수 있다, —> 재귀함수를 써야되는 근거가 된다.</p>\n<ul>\n<li>시간복잡도로 이진 탐색을 보면 기존의 일괄탐색은 O(n)인 반면</li>\n<li>이진탐색은 그의 반으로 줄어든다. O(logn)</li>\n</ul>\n<h2 id=\"2-재귀함수를-이용한-이진-탐색-알고리즘\"><a href=\"#2-%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"2 재귀함수를 이용한 이진 탐색 알고리즘 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 재귀함수를 이용한 이진 탐색 알고리즘</h2>\n<p>위에서 보았듯이 low index와 high index (mid index는 low와 high로 구할 수 있음), 찾을 대상인 list 그리고 찾을 목표 target이 필요한 인자임을 알 수 있다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def search(nums, target, low, high):\n    if low &gt; high:\n        return False\n\n    mid = (low + high) // 2\n\n    if nums[mid] == target:\n        return mid\n    elif nums[mid] &lt; target:\n        low = mid + 1\n    else:\n        high = mid - 1\n    return search(nums, target, low, high)</code></pre></div>\n<ul>\n<li>리턴을 search로 해서 계속 재귀하는 함수이고 재귀함수에는 종료조건이 있어야 하는데 그게 바로 첫행에 있는 low>high이다.</li>\n<li>low > high는 반으로 나누고 나누다가 결국 나눌 리스트 값이 존재하지 않는 경우이다. 이런경우 찾는 값이 없는 것이므로 False를 리턴하였다.</li>\n</ul>","fields":{"slug":"/posts/CodeAlgorithm/","tagSlugs":["/tag/python-algorithm-data-structure/"]},"frontmatter":{"date":"2019-12-06T23:30:03.284Z","description":"Search Methodology","tags":["Python/Algorithm/Data Structure"],"title":"Binary Search algorithm by python","socialImage":"/media/gutenberg.jpg"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/CodeAlgorithm/"}}}