{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/javascript-part4/","webpackCompilationHash":"bdf51a00a57e0916a26e","result":{"data":{"markdownRemark":{"id":"41a72833-021f-516f-a7fc-20da5c09038c","html":"<h2 id=\"array배열\"><a href=\"#array%EB%B0%B0%EC%97%B4\" aria-label=\"array배열 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array(배열)</h2>\n<p>비슷한 성질을 가진 데이터들의 집합</p>\n<blockquote>\n<p>배열의 요소(Elements)<br>\n<code>let name = [‘chris’, 2, test(name), [‘rs’, ‘esp’], function (price)]</code></p>\n</blockquote>\n<ul>\n<li>Element type – everything! – str /num / array / etc on..</li>\n</ul>\n<blockquote>\n<p>인덱싱 – 배열안에서 각 요소들은 주소값(?)을 가지고 있다. – 배열안의 요소를 쉽게 찾을 수 있도록 하는 기능이다.</p>\n</blockquote>\n<p><code>function getElement() {\nlet arr = [3, [4, [“array”, 9], 2+3], [0]];}</code>\n<code>return arr[1][1][0];}</code></p>\n<blockquote>\n<p>배열의 요소는 다양한 타입이 가능하다. 특히 배열안의 배열도 가능하다. 이렇게 [[[]]]- 배열 속에 배열이 있는 구조를 다차원 배열이라고 한다.\n그러면 다차원 배열의 인덱싱은 어떻게 할까??? 가장 바깥의 배열부터 안에 있는 배열 순서대로 인덱싱을 진행하면</p>\n</blockquote>\n<ol>\n<li>[1]-가장 바깥의 배열의 2번째 요소(이게 배열이다) - [4, [“array”, 9], 2+3],</li>\n<li>[1] - 1에서 인덱싱한 요소가 배열이고 이 배열에서 2번째 요소(이것도 배열) - [“array”, 9]</li>\n<li>[0] - 2에서 인덱싱한 요소가 배열이고 이 배열에서 1번째 요소 -“array”가 출력된다.</li>\n<li>배열 요소 추가하기</li>\n</ol>\n<p><code>let cities = [];</code></p>\n<ul>\n<li>array명[원하는 인덱싱] = 넣으려는 요소값</li>\n</ul>\n<p><code>cities[0] = “서울”;</code>\n<code>cities[1] = “대전”;</code>\n<code>cities[2] = “대구”;</code>\n<code>cities[2] = “부산”;</code> – 대구에서 부산으로 업뎃됨\n<code>cities.push(“포항”);</code></p>\n<ul>\n<li>요소 맨뒤에 위의 경우는 [3]에 “포항”을 집어 넣음</li>\n</ul>\n<p><code>cities.unshift(“강릉”);</code></p>\n<ul>\n<li>요소 맨앞에 위의 경우는 [0]에 “강릉”을 집어 넣음</li>\n</ul>\n<p><code>Cities.pop();</code></p>\n<ul>\n<li>맨 뒤에 있던 요소 “포항”이 날라감</li>\n</ul>\n<p>※ Callback 함수 – 인자로 전달되는 함수 – 함수에서 다시 불러와지는(콜백) 함수</p>\n<h4 id=\"arraymap\"><a href=\"#arraymap\" aria-label=\"arraymap permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array.map()</h4>\n<p>배열을 반복해주는데, callback 함수에서 return한 값으로 매 요소를 수정해준다.\nMap 메서드 return값은 수정도니 값으로 다시 생성된 배열.\nArray 타입의 데이터를 요소 갯수 만큼 반복합니다.\n반복할 때마다 실행할 함수를 parameter로 전달합니다.\n그러면 이 callback 함수에서 array의 요소를 인자(x)로 받습니다.\n해당 요소를 수정하고 싶은대로 로직을 구현하고 return해주면,\n해당 index의 요소가 return 된 값으로 치환됩니다.</p>\n<h4 id=\"arrayforeach\"><a href=\"#arrayforeach\" aria-label=\"arrayforeach permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array.forEach()</h4>\n<p>For 대신 사용하는 반복문\nforEach는 함수 자체가 return하는 것도 아무것도 없는게 큰 차이\nforEach함수를 탈출 하고 싶을 때 return을 사용하면 됨 – 지정 해줘야 됨 - for문에 종료조건에 따른 리턴 되는게 없으면 계속 반복하는 것 처럼</p>\n<h2 id=\"class\"><a href=\"#class\" aria-label=\"class permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Class</h2>\n<p>Object를 정의하는 프레임 혹은 설계\n원하는 구조의 객체의 프레임을 설계해 놓고, 비슷한 모양의 객체를 공장처럼 찍어낼 수 있다.\n비슷한 모양의 객체를 계속적으로 만드는 건 낭비 이걸 class라는 설계도를 통해 공통적인 부분의 중복 코딩을 막을 수 있다. 또한 코드 가독성 및 유지, 보수, 변경에도 훨씬 유리하다</p>\n<p>★ CSS에서 말하는 Class와는 개념이 다르다!!</p>\n<blockquote>\n<p>JS Class 작성 예시</p>\n</blockquote>\n<p><code class=\"language-text\">class Car {</code> 클래스명은 대문자 시작 CamelCase 작성 규칙</p>\n<p><code class=\"language-text\">constructor(name, price) {</code>생성자 영역 – 인자 2개 받음 context 밖에서 인스턴스 생성할때마다 맨 먼저 호출되는 부분(클래스를 시작하기 위한 첫 기초단계라고 생각하자)<br>\n<code class=\"language-text\">this.name = name;</code> this는 class 영역(context) 내에서 적용할 인스턴스 name인스턴스는 = 인자 name값 ø context(class 개념에서) = scope (함수 개념에서)<br>\n<code class=\"language-text\">this.price = price;</code> 위와 동일하고 price인스턴스 인자값만 price로<br>\n<code class=\"language-text\">this.department = &quot;선릉지점&quot;;</code> department 인스턴스는 “선릉지점” 값<br>\n<code class=\"language-text\">this.salesAmount = 0;</code>salesAmount 인스턴스는 0값<br>\n<code class=\"language-text\">}</code><br>\n<code class=\"language-text\">applyDiscount(discount) {</code>클래스 내에 생성되는 함수 = 메서드 à 객체가 프로터티 값으로 갖고 있다.<br>\n<code class=\"language-text\">return this.price * discount;</code> - this 인스턴스를 써야 class내에서는 통한다!<br>\n<code class=\"language-text\">} addSales() { this.salesAmount++; } changeDepartment(departmentName) { this.department = departmentName; } }</code></p>\n<h2 id=\"if문\"><a href=\"#if%EB%AC%B8\" aria-label=\"if문 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>if문</h2>\n<p>“만약에 ~하면 ~한다.”가 컴퓨터 언어로 변환</p>\n<blockquote>\n<p>|| and &#x26;&#x26;</p>\n</blockquote>\n<p><code class=\"language-text\">if (answer === &quot;선릉&quot; || answer === &quot;강남&quot; || answer === &quot;역삼&quot;)</code> - 선릉 or 강남 or 역삼인 경우</p>\n<ul>\n<li>||는 or 논리 연산자이다.</li>\n<li>&#x26;&#x26; and 논리 연산자\n<code class=\"language-text\">if (hobby === &quot;축구&quot; &amp;&amp; morning === &quot;네&quot;)</code> - hobby가 축구이고 morning이 네인 경우</li>\n</ul>\n<p>ex)\n<code class=\"language-text\">if (age &gt; 65 || age &lt; 21 &amp;&amp; res === &quot;한국&quot;)</code><br>\n=> 나이가 65세 초과이거나 나이가 21세 미만이고 한국거주하는 사람</p>\n<p>위의 코드는 가독성이 좋지 않으므로 밑에 처럼 () 처리하는게 좋다<br>\n<code class=\"language-text\">if (age &gt; 65 || (age &lt; 21 &amp;&amp; res === &quot;한국&quot;))</code></p>\n<p>만약에 이런 형식의 코드는 어떻게 해석이 될까?<br>\n<code class=\"language-text\">if ((age &gt; 65 || age &lt; 21) &amp;&amp; res === &quot;한국&quot;)</code><br>\n=> 나이가 65세 초과거나 21세미만이고 한국 거주하는 자</p>\n<h2 id=\"주석---주석-연산자--\"><a href=\"#%EC%A3%BC%EC%84%9D---%EC%A3%BC%EC%84%9D-%EC%97%B0%EC%82%B0%EC%9E%90--\" aria-label=\"주석   주석 연산자   permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주석 - 주석 연산자(//, /* */)</h2>","fields":{"slug":"/posts/javascript-part4/","tagSlugs":["/tag/java-script/"]},"frontmatter":{"date":"2019-10-10T23:45:03.284Z","description":"배열 / class / 주석","tags":["JavaScript"],"title":"09.30~10.04 한 주 정리 part.4","socialImage":"/media/gutenberg.jpg"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/javascript-part4/"}}}