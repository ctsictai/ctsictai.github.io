{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/javascript-part6/","webpackCompilationHash":"d4e6b2d9cbd89eab4d31","result":{"data":{"markdownRemark":{"id":"5dd28c67-c423-5675-a45f-94123a9020bd","html":"<h1 id=\"html에서의-js-로드하기\"><a href=\"#html%EC%97%90%EC%84%9C%EC%9D%98-js-%EB%A1%9C%EB%93%9C%ED%95%98%EA%B8%B0\" aria-label=\"html에서의 js 로드하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTML에서의 JS 로드하기</h1>\n<ul>\n<li>inline 방식 – html 태그에 직접 javascript를 기술하는 방식이다. 장점은 태그에 관련된 스크립트가 분명하게 드러난다. 하지만 정보와 제어가 섞여 있기 때문에 정보로서의 가치가 떨어짐.</li>\n<li>Script 방식 - script 태그를 만들어서 여기에 자바스크립트 코드를 삽입하는 방식. 장점은 html태그와 js 코드를 분리할 수 있다.</li>\n<li>외부 파일로 분리\njs를 별도의 파일로 분리할 수도 있다. 장점은 보다 엄격하게 정보와 제어를 분리할 수 있다. 하나의 js 파일을 여러 웹페이지에서 로드함으로서 js의 재활용성을 높일 수 있다. 캐쉬를 통해서 속도의 향상, 전송량의 경량화를 도모할 수 있다. 유지보수의 편의성(중복 제거)</li>\n</ul>\n<p>※ Scripts 파일은 태그보다 페이지 하단(body tag 안에서 맨뒤)에 위치시키는 것이 더 좋음</p>\n<h1 id=\"dom-document-object-model\"><a href=\"#dom-document-object-model\" aria-label=\"dom document object model permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DOM (Document Object Model)</h1>\n<ul>\n<li>DOM(돔)이란 웹페이지의 HTML을 계층화시켜 트리구조로 만든 객체(Object) 모델입니다.</li>\n<li>JavaScript는 이 model로 웹 페이지에 접근하고, 페이지를 수정할 수 있습니다.</li>\n<li>DOM은 HTML인 웹페이지와 스크립팅언어(JavaScript)를 서로 잇는 역할입니다.</li>\n</ul>\n<p>JS로 html문서를 제어하려면 젤 처음에 해야 하는 일이 제어의 대상에 해당되는 객체를 찾는 것이다.</p>\n<blockquote>\n<p>객체 찾는 방법은 document 객체의 조회 관련 메소드 이용</p>\n</blockquote>\n<ul>\n<li>document.getElementsByTagName – HTML tag 이름 ul/ li/ p/ div 으로 찾아냄 보통 tag가 중복되서 많이 쓰이므로 찾으려는 태그명에 대해 배열값으로 리턴한다.</li>\n<li>document.getElementsById – ID명으로 찾음 – ID는 유일한 값이므로 유일한 객체만 검색됨</li>\n<li>document.getElementsByClassName - class명으로 찾아냄 – 클래스도 같은 이름으로 여러 개가 쓰일 수 있으므로 tagName과 같게 배열값으로 리턴한다.</li>\n<li>document.querySelector – css의 선택자의 문법을 이용한 객체 조회 – 위의 3개를 다 쓸 수 있는 듯 but 1개만 검색됨</li>\n<li>\n<p>document.querySelectorall – css 선택자 모든 객체 조회 – 맨 위의 3개를 다 쓸 수 있는 강력한 도구</p>\n<blockquote>\n<p>속성 - 엘리먼트의 속성을 알아내고 변경하는 API – MTV 모델에서 많이 쓰임</p>\n</blockquote>\n</li>\n<li>Element.getAttribute(name) – 속성을 가져오는 것</li>\n<li>Element.setAttribute(name, value) – 속성을 변경, 추가 하는 것</li>\n<li>Element.hasAttribute(name); - 속성의 존재여부를 boolean값으로 확인</li>\n<li>Element.removeAttribute(name) ; - 속성을 제거하는 것</li>\n</ul>\n<h3 id=\"node-객체\"><a href=\"#node-%EA%B0%9D%EC%B2%B4\" aria-label=\"node 객체 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node 객체</h3>\n<blockquote>\n<p>관계 - 엘리먼트는 서로 부모, 자식, 혹은 형제자매 관계로 연결되어 있다.</p>\n<blockquote>\n<p>각각의 Node가 다른 Node와 연결된 정보를 보여주는 API를 통해서 문서를 프로그래밍적으로 탐색할 수 있다.</p>\n</blockquote>\n</blockquote>\n<ul>\n<li>Node.childNodes – 자식노드들을 유사배열에 담아서 리턴</li>\n<li>Node.firstChild – 첫번째 자식 노드</li>\n<li>Node.lastChild – 마지막 자식 노드</li>\n<li>Node.nextSibling – 다음 형제 노드</li>\n<li>Node.previousSibling – 이전형제 노드</li>\n<li>Node.contains() – 가지고 있는 자식 노드</li>\n<li>Node.hasChildNodes() – 특정 자식 노드를 가지고 있느냐 없느냐</li>\n</ul>\n<h3 id=\"노드의-종류\"><a href=\"#%EB%85%B8%EB%93%9C%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"노드의 종류 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드의 종류</h3>\n<blockquote>\n<p>Node 객체는 모든 구성요소를 대표하는 객체이기 때문에 각각의 구성요소가 어떤 카테고리에 속하는 것인지를 알려주는 식별자를 제공한다.</p>\n</blockquote>\n<ul>\n<li>Node.nodeType - 노드의 종류에 따라서 정해진 상수가 존재한다.</li>\n<li>\n<p>Node.nodeName – name은 태그명을 의미한다.</p>\n<blockquote>\n<p>값 - Node 객체의 값을 제공하는 API</p>\n</blockquote>\n</li>\n<li>Node.nodeValue</li>\n<li>\n<p>Node.textContent</p>\n<blockquote>\n<p>자식관리 - Node 객체의 자식을 추가하는 방법에 대한 API</p>\n</blockquote>\n</li>\n<li>★ Node.appendChild()</li>\n<li>Node.removeChild()</li>\n</ul>\n<h3 id=\"노드-추가\"><a href=\"#%EB%85%B8%EB%93%9C-%EC%B6%94%EA%B0%80\" aria-label=\"노드 추가 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드 추가</h3>\n<ul>\n<li>appendChild(child)- 노드의 마지막 자식으로 주어진 엘리먼트 추가</li>\n<li>\n<p>insertBefore(newElement, referenceElement) - appendChild와 동작방법은 같으나 두번째 인자로 엘리먼트를 전달 했을 때 이것 앞에 엘리먼트가 추가된다.</p>\n<blockquote>\n<p>위치 지정해서 엘리먼트를 추가하는 방법\n노드를 추가하기 위해서는 추가할 엘리먼트를 생성해야 하는데 이것은 document 객체의 기능이다. 아래 API는 노드를 생성하는 API이다.</p>\n</blockquote>\n</li>\n<li>document.createElement(tagName) -엘리먼트 노드를 추가한다.</li>\n<li>document.createTextNode(data) - 텍스트 노드를 추가한다.</li>\n</ul>\n<h3 id=\"노드-제거\"><a href=\"#%EB%85%B8%EB%93%9C-%EC%A0%9C%EA%B1%B0\" aria-label=\"노드 제거 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드 제거</h3>\n<p>메소드는 삭제 대상의 부모 노드 객체의 것을 실행해야 한다는 점에 유의하자.</p>\n<ul>\n<li>removeChild(child)</li>\n</ul>\n<h3 id=\"노드-교체\"><a href=\"#%EB%85%B8%EB%93%9C-%EA%B5%90%EC%B2%B4\" aria-label=\"노드 교체 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드 교체</h3>\n<ul>\n<li>replaceChild(newchild, oldchild)</li>\n</ul>\n<h3 id=\"문자열로-노드-제어-위의-방법보다-훨씬-쉬움\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4%EB%A1%9C-%EB%85%B8%EB%93%9C-%EC%A0%9C%EC%96%B4-%EC%9C%84%EC%9D%98-%EB%B0%A9%EB%B2%95%EB%B3%B4%EB%8B%A4-%ED%9B%A8%EC%94%AC-%EC%89%AC%EC%9B%80\" aria-label=\"문자열로 노드 제어 위의 방법보다 훨씬 쉬움 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문자열로 노드 제어 (위의 방법보다 훨씬 쉬움)</h3>\n<ul>\n<li>innerHTML - 문자열로 자식 노드를 만들 수 있는 기능을 제공한다. 또한 자식 노드의 값을 읽어올 수도 있다. 선택한 엘리먼트는 검색되지 않는다 (부모노드는 검색 범위에서 제외)</li>\n<li>outerHTML - outerHTML은 선택한 엘리먼트를 포함해서 처리된다.</li>\n</ul>\n<h1 id=\"이벤트\"><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8\" aria-label=\"이벤트 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이벤트</h1>\n<p>★ addEventListener() 메서드 ★</p>\n<p><code>target.addEventListener(type, listener[, options]);</code></p>\n<p><code>target:이벤트 발생시킬 타겟(이게 젤중요함 어디에 적용되느냐!!) (type:이벤트 종류, listener: 이벤트 작동할 로직 or 로직 있는함수\n[,이벤트 특성])</code></p>\n<ul>\n<li>EventTarget의 addEventListener() 메서드는 지정한 이벤트가 대상에 전달될 때마다 호출할 함수를 설정합니다. 일반적인 대상은 Element, Document, Window지만, XMLHttpRequest와 같이 이벤트를 지원하는 모든 객체를 대상으로 지정할 수 있습니다.</li>\n<li>addEventListener()는 EventTarget의 주어진 이벤트 유형에, EventListener를 구현한 함수 또는 객체를 이벤트 처리기 목록에 추가해 작동합니다.</li>\n</ul>\n<blockquote>\n<p>키이벤트</p>\n</blockquote>\n<p>사람이 키보드를 누르면 발생하는 이벤트 입니다.</p>\n<ul>\n<li>키보드를 눌렀을 때 발생하는 keydown</li>\n<li>키보드를 누르고 떼는 순간 발생하는 keyup</li>\n<li>키보드를 눌러 어떤 텍스트가 작성되는 순간 발생하는 keypress</li>\n</ul>\n<p>등등 더 많은 이벤트가 존재한다 다른 이벤트를 보려면 밑의 링크를 클릭하시면 됩니다.</p>\n<p>[<a href=\"https://developer.mozilla.org/ko/docs/Web/Events\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">이벤트 종류 더 보기</a>]</p>","fields":{"slug":"/posts/javascript-part6/","tagSlugs":["/tag/java-script/"]},"frontmatter":{"date":"2019-10-14T23:55:03.284Z","description":"HTML에서의 JS / DOM / 이벤트","tags":["JavaScript"],"title":"09.30~10.04 한 주 정리 part.6","socialImage":"/media/gutenberg.jpg"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/javascript-part6/"}}}